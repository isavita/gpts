# Generate Advent Of Code solutions with LLM

```elixir
Mix.install([
  :req,
  :json
])
```

## Load all advent of code from hugging face

```elixir
dataset_url = "https://huggingface.co/datasets/isavita/advent-of-code/resolve/main/train.json"
dataset = Req.get!(dataset_url).body
```

```elixir
defmodule Constants do
  def file_ext, do: ".cpp"
  def lang, do: "cpp"
  def compiler, do: "/usr/bin/g++"
  def runtime, do: "/Users/isavita/test"
end
```

```elixir
program = ~S|
#include <iostream>

int main() {
    std::cout << "Hello, World!" << std::endl;
    return 0;
}
|
File.write!("test#{Constants.file_ext()}", program)

System.cmd(Constants.compiler(), ["test#{Constants.file_ext()}", "-std=c++11", "-o", "test"],
  stderr_to_stdout: true
)

System.cmd(Constants.runtime(), [], stderr_to_stdout: true)
```

```elixir
solutions = File.ls!("#{File.cwd!()}/code/advent_generated")
solved_parts = Enum.map(solutions, &String.replace(&1, Constants.file_ext(), ""))

dataset_202X =
  Enum.filter(dataset, fn part ->
    part["solution_lang"] == "go" && part["name"] not in solved_parts
  end)
```

## Manage Request to Mistral API

```elixir
defmodule MistralClient do
  # 5 mins
  @timeout 300_000
  @url "https://api.mistral.ai/v1/chat/completions"
  @system_prompt """
  You are an expert programmer that writes simple, concise code and no comments or explanation.
  Write a elixir module that it reads its input from a file "input.txt" and solve the following task.
  The module should have only one public function called `call` with arity 0.
  The answer should be RETURN instead of printed in the stdout.
  TASK:
  """
  def call(model, task) do
    prompt = "#{@system_prompt}#{task}"

    payload =
      %{
        "model" => model,
        "messages" => [
          %{"role" => "user", "content" => prompt}
        ],
        "temperature" => 0.1,
        "stream" => false
      }
      |> Jason.encode!()

    Req.post!(@url, body: payload, headers: headers(), receive_timeout: @timeout).body
    |> Map.get("choices", [%{}])
    |> hd()
    |> get_in(["message", "content"])
  end

  defp headers do
    [
      {"Content-Type", "application/json"},
      {"Accept", "application/json"},
      {"Authorization", "Bearer " <> mistral_api_key()}
    ]
  end

  defp mistral_api_key, do: System.fetch_env!("LB_MISTRAL_API_KEY")
end
```

````elixir
defmodule OpenAIClient do
  # 10 mins
  @timeout 600_000
  @url "https://api.openai.com/v1/chat/completions"
  @system_prompt """
  You are an expert programmer that writes simple, concise code and no comments or explanation.
  Write a elixir module that it reads its input from a file "input.txt" and solve the following task.
  The module should have only one public function called `call` with arity 0.
  The answer should be RETURN instead of printed in the stdout.
  HERE ARE SOME IMPLEMENTATION that you can copy and paste and add to your code of helpful functions:
  ```
  defp min(a, b) do
    if a < b, do: a, else: b
  end

  defp max(a, b) do
    if a > b, do: a, else: b
  end

  defp string_replace_at(original, index, replacement) do
    {head, tail} = String.split_at(original, index)
    replacement_length = String.length(replacement)

    head <> replacement <> String.slice(tail, replacement_length, String.length(tail) - replacement_length)
  end

    iex> String.graphemes("Ńaïve")
    ["Ń", "a", "ï", "v", "e"]


  # Depth First Search function
  defp dfs(graph, start_node) do
    dfs_recursive(graph, start_node, MapSet.new(), [])
  end

  # Recursive helper function for DFS
  defp dfs_recursive(graph, current_node, visited, path) do
    if MapSet.member?(visited, current_node) do
      {visited, path}
    else
      new_visited = MapSet.put(visited, current_node)
      new_path = [current_node | path]

      Enum.reduce(graph[current_node] || [], {new_visited, new_path}, fn neighbor, {vis, pth} ->
        dfs_recursive(graph, neighbor, vis, pth)
      end)
    end
  end

  # Breadth First Search function
  defp bfs(graph, start_node) do
    bfs_queue([start_node], MapSet.new([start_node]), graph, [])
  end

  defp bfs_queue([], _visited, _graph, acc), do: Enum.reverse(acc)

  defp bfs_queue([current_node | rest], visited, graph, acc) do
    neighbors = graph[current_node] || []
    unvisited_neighbors = Enum.filter(neighbors, &(!MapSet.member?(visited, &1)))
    new_visited = Enum.reduce(unvisited_neighbors, visited, &MapSet.put(&2, &1))
    bfs_queue(rest ++ unvisited_neighbors, new_visited, graph, [current_node | acc])
  end
  ```
  TASK:
  """
  def call(model, task, system_prompt \\ @system_prompt) do
    prompt = "#{system_prompt}#{task}"

    payload =
      %{
        "model" => model,
        "temperature" => 0.6,
        "messages" => [
          %{"role" => "user", "content" => prompt}
        ]
      }
      |> Jason.encode!()

    Req.post!(@url, body: payload, headers: headers(), receive_timeout: @timeout).body
    |> Map.get("choices", [%{}])
    |> hd()
    |> get_in(["message", "content"])
  end

  defp headers do
    [
      {"authorization", "Bearer #{openai_api_key()}"},
      {"content-type", "application/json"},
      {"accept", "application/json"}
    ]
  end

  defp openai_api_key, do: System.fetch_env!("LB_OPENAI_API_KEY")
end
````

```elixir
defmodule RunWithTimeout do
  def call(fun, timeout) do
    task =
      Task.async(fn ->
        try do
          # Attempt to run the function
          result = fun.()
          {:ok, result}
        rescue
          exception ->
            # If an exception occurs, return an error tuple
            {:error, Exception.message(exception)}
        end
      end)

    try do
      Task.await(task, timeout)
    rescue
      # Catches exceptions and converts them to a tuple
      exception ->
        {:error, Exception.message(exception)}
    catch
      # Catches exits such as those from Task.await timeout
      :exit, _ ->
        # Ensures that the task is not left running
        Task.shutdown(task, :brutal_kill)

        # System.cmd("pgrep", ["-f", "test#{Constants.file_ext()}"], stderr_to_stdout: true)
        {output, _} =
          System.cmd("pgrep", ["-f", "test"], stderr_to_stdout: true)
          |> IO.inspect(label: "kill")

        kill_os_process(output) |> IO.inspect(label: "kill")
        {:error, "The operation timed out."}

      # Catches throws, which are non-standard in Elixir but still possible
      :throw, value ->
        {:error, "The operation was aborted: #{inspect(value)}"}
    end
  end

  defp kill_os_process(output) do
    Enum.each(String.split(output, "\n"), fn pid ->
      # Ignore empty lines
      if pid != "" do
        # Kill each process found
        System.cmd("kill", [pid])
      else
        :ok
      end
    end)
  end
end
```

```elixir
"""
defmodule SafeCracking do def call do "input.txt" |> File.read!() |> calculate() |> Keyword.get(:a) end defp parse_line(line) do line |> String.split(" ") |> Enum.map(&parse_elem/1) end defp parse_elem(value), do: parse_elem(value, Integer.parse(value)) defp parse_elem(value, :error), do: String.to_atom(value) defp parse_elem(_value, {int, ""}), do: int defp loop(list), do: loop(list, 0, init()) defp loop(list, pointer, info) when pointer >= length(list), do: info defp loop(list, pointer, info) do item = Enum.at(list, pointer) {list, pointer, info} = execute(item, list, pointer, info) loop(list, pointer, info) end defp execute([:cpy, _value, elem], list, pointer, info) when is_integer(elem) do IO.puts("This shouldn't happen") 1 / 0 {list, pointer + 1, info} end defp execute([:cpy, value, elem], list, pointer, info) do value = parse_value(info, value) info = set(info, elem, value) {list, pointer + 1, info} end defp execute([:inc, elem], list, pointer, info) do info = set(info, elem, get(info, elem) + 1) {list, pointer + 1, info} end defp execute([:dec, elem], list, pointer, info) do info = set(info, elem, get(info, elem) - 1) {list, pointer + 1, info} end defp execute([:jnz, value, change], list, pointer, info) do value = parse_value(info, value) change = parse_value(info, change) pointer = if (value == 0), do: pointer + 1, else: pointer + change {list, pointer, info} end defp execute([:tgl, elem], list, pointer, info) do toggle_index = get(info, elem) + pointer item = Enum.at(list, toggle_index) list = toggle_elem(list, toggle_index, item) {list, pointer + 1, info} end defp toggle_elem(list, _, nil), do: list defp toggle_elem(list, index, item) do item = toggle_instruction(item) List.replace_at(list, index, item) end defp toggle_instruction([:inc, elem]), do: [:dec, elem] defp toggle_instruction([_, elem]), do: [:inc, elem] defp toggle_instruction([:jnz, a, b]), do: [:cpy, a, b] defp toggle_instruction([_, a, b]), do: [:jnz, a, b] defp get(info, elem), do: Keyword.get(info, elem) defp set(info, elem, value) do Keyword.put(info, elem, value) end defp parse_value(_info, value) when is_integer(value), do: value defp parse_value(info, value), do: get(info, value) defp init do [a: 7, b: 0, c: 0, d: 0] end defp calculate(input) do input |> String.split("\n") |> List.delete_at(-1) |> Enum.map(&parse_line/1) |> loop end end
"""
```

## Manage Request to local ollama model

```elixir
defmodule OllamaClient do
  # 5 mins
  @timeout 300_000
  @url "http://localhost:11434/api/generate"
  @system_prompt """
  You are an expert programmer that writes simple, concise code and no comments or explanation.
  Write a elixir module that it reads its input from a file "input.txt" and solve the following task.
  The module should have only one public function called `call` with arity 0.
  The answer should be RETURN instead of printed in the stdout.
  TASK:
  """
  def call(model, task) do
    prompt = "#{@system_prompt}#{task}"

    payload =
      Jason.encode!(%{
        "model" => model,
        "prompt" => prompt,
        "stream" => false
      })

    Req.post!(@url, body: payload, receive_timeout: @timeout).body["response"]
  end
end
```

## Code evaluator

```elixir
defmodule EvaluateCode do
  def call(code, file_content) do
    try do
      File.write!("test#{Constants.file_ext()}", code |> IO.inspect(label: "code"))
      File.write!("input.txt", file_content) |> IO.inspect()

      System.cmd(
        Constants.compiler(),
        ["test#{Constants.file_ext()}", "-std=c++11", "-o", "test"],
        stderr_to_stdout: true
      )
      |> IO.inspect(label: "compiler")

      File.cwd!() |> IO.inspect()

      {:ok, {result, exit_status}} =
        RunWithTimeout.call(
          fn ->
            System.cmd(Constants.runtime(), [], stderr_to_stdout: true)
            |> IO.inspect(label: "run")
          end,
          30_000
        )
        |> IO.inspect(label: "here")

      if exit_status == 0 do
        {:ok, inspect(result)}
      else
        {:error, "Error status #{exit_status}"}
      end
    rescue
      exception ->
        {:error, Exception.message(exception)}
    end
  end
end
```

```elixir
System.cmd("/Users/isavita/test", [], stderr_to_stdout: true)
```

## Add mutiple time FunctionRunner

````elixir
defmodule CodeResponseSanitizer do
  def call(input) when is_binary(input) do
    input
    |> String.replace(~r/^(\n|.)*```#{Constants.lang()}/, "")
    |> String.replace(~r/```(\n|.)*$/, "")
  end
end

defmodule FunctionRunner do
  def run_max_times(function, max_attempts) do
    do_run_max_times(function, max_attempts, 1)
  end

  defp do_run_max_times(function, max_attempts, attempt) when attempt <= max_attempts do
    case function.() do
      :ok -> :ok
      _ -> do_run_max_times(function, max_attempts, attempt + 1)
    end
  end

  defp do_run_max_times(_function, _max_attempts, _attempt), do: :error
end

task_solver_fn = fn day ->
  # task = Map.fetch!(day, "task")
  input = Map.fetch!(day, "input")
  answer = Map.fetch!(day, "answer")
  solution = Map.fetch!(day, "solution")

  # system_prompt = """
  # You are an expert programmer that writes simple, concise code and no comments or explanation.
  # Write a #{Constants.file_ext()} script that it reads its input from a file "input.txt" and solve the following task.
  # The program should print the answer as result of running the `#{Constants.compiler()} script#{Constants.file_ext()}`.
  # """

  system_prompt = """
  You are an expert programmer that writes simple, concise code and no comments or explanation.
  Given this golang program write a #{Constants.file_ext()} version that it reads its input from a file "input.txt" and solve the following task.
  The program should print the answer on the stdout and can be run `#{Constants.runtime()} solution#{Constants.file_ext()}`.

  Ensure all functions or variables are declared before use. If a function is used before its definition, declare it at the beginning of your code or in a header file.
  Always insert a space between consecutive right angle brackets in template declarations to ensure compatibility with older C++ standards. For example, use std::vector<std::vector<int> > instead of std::vector<std::vector<int>>.
  Use appropriate constructors for non-aggregate types like std::vector or std::unordered_map instead of brace initialization when not directly supported.
  Include the correct header for the function you are trying to use. For std::accumulate, include <numeric> at the beginning of your file.

  Golang Task:
  """

  # "gpt-4-turbo-preview" OllamaClient.call("deepseek-coder:6.7b", task) 
  with module_string <- OpenAIClient.call("gpt-3.5-turbo-0125", solution, system_prompt),
       module_sanitized <- CodeResponseSanitizer.call(module_string),
       {:ok, result} <- EvaluateCode.call(module_sanitized, input),
       true <- String.contains?(result, answer) |> IO.inspect(label: 4) do
    path =
      ~s|#{System.get_env("HOME")}/code/advent_generated/#{day["name"]}#{Constants.file_ext()}|

    File.write!(path, module_sanitized) |> IO.inspect(label: 5)
  else
    error -> error
  end
end
````

```elixir
len = length(dataset_202X)

Enum.reduce(dataset_202X, 1, fn day, count ->
  FunctionRunner.run_max_times(fn -> task_solver_fn.(day) end, 1)
  :io.format("~.1f%\n", [count / len * 100])
  count + 1
end)
```

<!-- livebook:{"offset":14175,"stamp":{"token":"XCP.rxJvacNaKNhUZg1bPfuqVQHQI1NcR-m0a40JOw9FvBxbQCDEmQqjjEv7G2h94m9Xq0jqfBRoZOxNGb6ydzOcqLJW7JCvcZI-ZMOOk3eBmTKV3rMiuE591PAGxWdKYHMik02v-IDtCeWhyRrVAw","version":2}} -->
